# Reference Counts
In C, the programmer is responsible for dynamic allocation and deallocation of memory on the heap. This is done using **malloc()** and **free()**. Every block of memory allocated with **malloc()** should eventually be returned to the pool of available memory by exactly one call to **free()**. If a block's address is forgotten but **free()** is not called for it, the memory it occupies cannot be reused until the program terminates. This is called a *memory leak*.

Common causes for memory leaks are unusual paths through the code. It's important to prevent leaks from happening by having a coding convention or strategy that minimizes this kind of errors. Python has chosen the *reference counting* method: every object contains a counter, which is incremented when a reference to the object is stored somewhere, and is decremented when a reference to it is deleted. When the counter reaches zero, the last reference to the object has been deleted and the object is freed.

An alternative strategy is called *automatic garbage collection*. The advantage is that the user doesn't need to call **free()** explicitly. The disadvantage is that for C, there is no portable automatic garbage collector.

The macros **Py_INCREF(x)** and **Py_DECREF(x)** handle the incrementing and decrementing of the reference count, with the latter also freeing the object when the count reaches zero.

Nobody owns an object; however, you can *own a reference* to an object. An object's reference count is defined as the number of owned references to it. The owner of a reference is responsible for calling **Py_DECREF()** when the reference is no longer needed. Ownership of a reference can be transferred. Forgetting to dispose of an owned reference creates a memory leak. It is also possible to *borrow* a reference to an object. The borrower should not call **Py_DECREF()** and it must not hold on to the object longer than the owner from which it was borrowed. The advantage of borrowing over owning is that you don't need to take care of disposing of the reference on all possible paths through the code. A borrowed reference can be changed into an owned reference by calling **Py_INCREF()**.

Whenever an object reference is passe into or out of a function, it is part of the function's interface specification whether ownership is transferred with the reference or not. Most functions that return a reference to an object pass on ownership with the reference. Many funtions that extract objects from other objects also transfer ownership with the reference. When a C function is called from Python, it borrows references to its arguments from the caller. The caller owns a reference to the object, so the borrowed reference's lifetime is guaranteed until the function returns. The object reference returned from a C function that is called in Python must be an owned reference - ownership is transferred from the function to its caller.

In general, functions that take object references as arguments do not expect you t pass them **NULL** pointers, and will dump core if you do so. It is better to test for **NULL** only at the source, like **malloc()** or a function that may raise an exception. **Py_XINCREF()** and **Py_XDECREF()** check for **NULL** pointers. The C function calling mechanism guarantees that the argument list passed to C functions (**args**) is never **NULL**, in fact it is always a tuple.